<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>three.js examples</title>
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link rel="shortcut icon" href="#" />
		<link rel="stylesheet" type="text/css" href="main.css" />
		<style>
			#panel #content .link {
				display: block;
			}
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from "../build/three.module.js";

			import { GUI } from "./jsm/libs/dat.gui.module.js";

			import { OrbitControls } from "./jsm/controls/OrbitControls.js";

			import { TeapotBufferGeometry } from "./jsm/geometries/TeapotBufferGeometry.js";

			var camera, scene, renderer;
			var cameraControls;
			var effectController;
			var teapotSize = 400;
			var ambientLight, light;

			var tess = -1; // force initialization
			var bBottom;
			var bLid;
			var bBody;
			var bFitLid;
			var bNonBlinn;
			var shading;
			var wireMaterial,
				flatMaterial,
				gouraudMaterial,
				texturedMaterial,
				reflectiveMaterial;

			var teapot, textureCube;

			// allocate these just once
			var diffuseColor = new THREE.Color();
			var specularColor = new THREE.Color();

			init();
			render();

			function init() {
				var container = document.createElement("div");
				document.body.appendChild(container);

				var canvasWidth = window.innerWidth;
				var canvasHeight = window.innerHeight;

				// CAMERA
				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					1,
					80000
				);
				camera.position.set(-600, 550, 1300);

				// LIGHTS
				ambientLight = new THREE.AmbientLight(0x333333); // 0.2

				light = new THREE.DirectionalLight(0xffffff, 1.0);
				// direction is set in GUI

				// RENDERER
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(canvasWidth, canvasHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild(renderer.domElement);

				// EVENTS
				window.addEventListener("resize", onWindowResize, false);

				// CONTROLS
				cameraControls = new OrbitControls(camera, renderer.domElement);
				cameraControls.addEventListener("change", render);

				// TEXTURE MAP
				var textureMap = new THREE.TextureLoader().load(
					"textures/tri_pattern.jpg"
				);

				// MATERIALS
				var materialColor = new THREE.Color();
				materialColor.setRGB(1.0, 1.0, 1.0);

				gouraudMaterial = new THREE.MeshLambertMaterial({
					color: materialColor,
					side: THREE.DoubleSide
				});

				texturedMaterial = new THREE.MeshPhongMaterial({
					color: materialColor,
					map: textureMap,
					side: THREE.DoubleSide
				});

				// scene itself
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xaaaaaa);

				scene.add(ambientLight);
				scene.add(light);

				// GUI
				setupGui();
			}

			// EVENT HANDLERS

			function onWindowResize() {
				var canvasWidth = window.innerWidth;
				var canvasHeight = window.innerHeight;

				renderer.setSize(canvasWidth, canvasHeight);

				camera.aspect = canvasWidth / canvasHeight;
				camera.updateProjectionMatrix();

				render();
			}

			function setupGui() {
				effectController = {
					shininess: 40.0,
					ka: 0.17,
					kd: 0.51,
					ks: 0.2,
					metallic: true,

					hue: 0.121,
					saturation: 0.73,
					lightness: 0.66,

					lhue: 0.04,
					lsaturation: 0.01, // non-zero so that fractions will be shown
					llightness: 1.0,

					lx: 0.32,
					ly: 0.39,
					lz: 0.7,
					newTess: 15,
					bottom: true,
					lid: true,
					body: true,
					fitLid: false,
					nonblinn: false,
					newShading: "smooth"
				};

				var h;

				var gui = new GUI();

				gui
					.add(effectController, "newShading", ["smooth", "textured"])
					.name("Shading")
					.onChange(render);
			}

			//

			function render() {
				if (
					effectController.newTess !== tess ||
					effectController.bottom !== bBottom ||
					effectController.lid !== bLid ||
					effectController.body !== bBody ||
					effectController.fitLid !== bFitLid ||
					effectController.nonblinn !== bNonBlinn ||
					effectController.newShading !== shading
				) {
					tess = effectController.newTess;
					bBottom = effectController.bottom;
					bLid = effectController.lid;
					bBody = effectController.body;
					bFitLid = effectController.fitLid;
					bNonBlinn = effectController.nonblinn;
					shading = effectController.newShading;

					createNewTeapot();
				}

				// We're a bit lazy here. We could check to see if any material attributes changed and update
				// only if they have. But, these calls are cheap enough and this is just a demo.
				texturedMaterial.shininess = effectController.shininess;

				diffuseColor.setHSL(
					effectController.hue,
					effectController.saturation,
					effectController.lightness
				);
				if (effectController.metallic) {
					// make colors match to give a more metallic look
					specularColor.copy(diffuseColor);
				} else {
					// more of a plastic look
					specularColor.setRGB(1, 1, 1);
				}

				diffuseColor.multiplyScalar(effectController.kd);
				gouraudMaterial.color.copy(diffuseColor);
				texturedMaterial.color.copy(diffuseColor);

				specularColor.multiplyScalar(effectController.ks);
				texturedMaterial.specular.copy(specularColor);

				// Ambient's actually controlled by the light for this demo
				ambientLight.color.setHSL(
					effectController.hue,
					effectController.saturation,
					effectController.lightness * effectController.ka
				);

				light.position.set(
					effectController.lx,
					effectController.ly,
					effectController.lz
				);
				light.color.setHSL(
					effectController.lhue,
					effectController.lsaturation,
					effectController.llightness
				);

				// skybox is rendered separately, so that it is always behind the teapot.
				if (shading === "reflective") {
					scene.background = textureCube;
				} else {
					scene.background = null;
				}

				renderer.render(scene, camera);
			}

			// Whenever the teapot changes, the scene is rebuilt from scratch (not much to it).
			function createNewTeapot() {
				if (teapot !== undefined) {
					teapot.geometry.dispose();
					scene.remove(teapot);
				}

				var teapotGeometry = new TeapotBufferGeometry(
					teapotSize,
					tess,
					effectController.bottom,
					effectController.lid,
					effectController.body,
					effectController.fitLid,
					!effectController.nonblinn
				);

				teapot = new THREE.Mesh(
					teapotGeometry,
					shading === "smooth"
						? gouraudMaterial
						: shading === "textured"
						? texturedMaterial
						: reflectiveMaterial
				); // if no match, pick Phong

				scene.add(teapot);
			}
		</script>
	</body>
</html>
